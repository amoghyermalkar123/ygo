This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-12T04:45:41.288Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
internal/
  block/
    block.go
  blockstore/
    store_test.go
    store.go
  clock/
    clock.go
  marker/
    marker_test.go
    marker.go
  replay/
    types.go
  sync/
    update.go
  utils/
    utils.go
test/
  blockstore_test.go
main.go

================================================================
Repository Files
================================================================

================
File: internal/block/block.go
================
package block

type ID struct {
	Clock  uint64
	Client uint64
}

type Block struct {
	ID        ID
	Content   string
	IsDeleted bool

	LeftOrigin  *ID
	RightOrigin *ID
	Left        *Block
	Right       *Block
}

// NewBlock creates a block with content and ID.
func NewBlock(id ID, content string) *Block {
	return &Block{
		ID:      id,
		Content: content,
	}
}

// AttachNeighbor links the block between left and right.
func (b *Block) AttachNeighbor(left, right *Block) {
	if left != nil {
		left.Right = b
	}
	if right != nil {
		right.Left = b
	}
	b.Left = left
	b.Right = right
}

================
File: internal/blockstore/store_test.go
================
package blockstore

================
File: internal/blockstore/store.go
================
package blockstore

import (
	"fmt"
	"ygo/internal/block"
	"ygo/internal/marker"
	"ygo/internal/utils"
)

type BlockStore struct {
	Start        *block.Block
	Length       int
	Clock        uint64
	Blocks       map[block.ID]*block.Block
	StateVector  map[uint64]uint64
	MarkerSystem *marker.MarkerSystem
}

// NewStore initializes a new BlockStore.
func NewStore() *BlockStore {
	return &BlockStore{
		Blocks:       make(map[block.ID]*block.Block),
		StateVector:  make(map[uint64]uint64),
		MarkerSystem: marker.NewSystem(),
	}
}

func (s *BlockStore) getNextClock() uint64 {
	s.Clock++
	return s.Clock
}

func (s *BlockStore) updateState(block *block.Block) {
	current := s.StateVector[block.ID.Client]
	if block.ID.Clock > current {
		s.StateVector[block.ID.Client] = block.ID.Clock
	}
}

func (s *BlockStore) GetState(client uint64) uint64 {
	return s.StateVector[client]
}

func (s *BlockStore) GetMissing(blk *block.Block) *uint64 {
	check := func(origin *block.ID) *uint64 {
		if origin != nil && origin.Client != blk.ID.Client && origin.Clock > s.GetState(origin.Client) {
			return &origin.Client
		}
		return nil
	}
	if m := check(blk.LeftOrigin); m != nil {
		return m
	}
	if m := check(blk.RightOrigin); m != nil {
		return m
	}
	return nil
}

// InsertText inserts content at a given position (supports split).
func (s *BlockStore) InsertText(pos int, content string, clientID uint64) error {
	id := block.ID{Clock: s.getNextClock(), Client: clientID}
	newBlock := block.NewBlock(id, content)

	if s.Start == nil {
		s.Start = newBlock
		s.MarkerSystem.Add(newBlock, 0)
		s.Blocks[id] = newBlock
		s.Length += len(content)
		s.updateState(newBlock)
		return nil
	}

	marker, err := s.MarkerSystem.FindBlock(s.Start, pos)
	if err != nil {
		return fmt.Errorf("find block: %w", err)
	}

	// Append to end
	curr := s.Start
	for curr.Right != nil {
		curr = curr.Right
	}

	newBlock.AttachNeighbor(curr, nil)
	s.Blocks[id] = newBlock
	s.MarkerSystem.Add(newBlock, s.Length)
	s.Length += len(content)
	s.updateState(newBlock)

	// Determine split point inside the block
	blockOffset := pos - s.markerPos(marker.Block)
	s.SplitAndInsert(marker.Block, newBlock, blockOffset)
	s.Blocks[id] = newBlock
	s.Length += len(content)
	s.updateState(newBlock)

	return nil
}

// SplitAndInsert splits target block at `splitAt` and inserts newBlock in between.
func (s *BlockStore) SplitAndInsert(target *block.Block, newBlock *block.Block, splitAt int) {
	leftContent := target.Content[:splitAt]
	rightContent := target.Content[splitAt:]

	// Create new blocks from the split
	leftBlock := block.NewBlock(block.ID{Clock: s.getNextClock(), Client: target.ID.Client}, leftContent)
	rightBlock := block.NewBlock(block.ID{Clock: s.getNextClock(), Client: target.ID.Client}, rightContent)

	// Link: left -> new -> right
	leftBlock.AttachNeighbor(target.Left, newBlock)
	newBlock.AttachNeighbor(leftBlock, rightBlock)
	rightBlock.AttachNeighbor(newBlock, target.Right)

	// Update start if needed
	if s.Start == target {
		s.Start = leftBlock
	}

	// Replace marker
	s.MarkerSystem.DeleteMarkerAt(s.markerPos(target))
	s.MarkerSystem.Add(leftBlock, s.markerPos(target))
	s.MarkerSystem.Add(newBlock, s.markerPos(target)+len(leftContent))
	s.MarkerSystem.Add(rightBlock, s.markerPos(target)+len(leftContent)+len(newBlock.Content))

	// Remove original block
	delete(s.Blocks, target.ID)
}

func (s *BlockStore) Integrate(remoteBlock *block.Block) {
	if remoteBlock.Left != nil || remoteBlock.Right != nil {
		// Already linked â€“ assume resolved
		return
	}

	var left *block.Block
	if remoteBlock.LeftOrigin != nil {
		left = s.Blocks[*remoteBlock.LeftOrigin]
	}

	// Find the first conflict candidate
	o := s.Start
	if left != nil {
		o = left.Right
	}

	// Sets for conflict detection
	conflicts := map[block.ID]bool{}
	seenBefore := map[block.ID]bool{}

	for o != nil && o != nil && !utils.EqualID(o.ID, *remoteBlock.RightOrigin) {
		conflicts[o.ID] = true
		if o.LeftOrigin != nil {
			seenBefore[*o.LeftOrigin] = true
		}

		// Compare origins
		if utils.EqualIDPtr(o.LeftOrigin, remoteBlock.LeftOrigin) {
			// Order by client ID
			if o.ID.Client < remoteBlock.ID.Client {
				left = o
				conflicts = map[block.ID]bool{}
			} else if utils.EqualIDPtr(o.RightOrigin, remoteBlock.RightOrigin) {
				break
			}
		} else if o.LeftOrigin != nil {
			// Origin crossing logic
			if seenBefore[*o.LeftOrigin] && !conflicts[*o.LeftOrigin] {
				left = o
				conflicts = map[block.ID]bool{}
			}
		}
		o = o.Right
	}

	// Reconnect neighbors
	remoteBlock.Left = left
	if left != nil {
		remoteBlock.Right = left.Right
		left.Right = remoteBlock
	} else {
		remoteBlock.Right = s.Start
		s.Start = remoteBlock
	}

	if remoteBlock.Right != nil {
		remoteBlock.Right.Left = remoteBlock
	}

	s.Blocks[remoteBlock.ID] = remoteBlock
	s.updateState(remoteBlock)
}

func (s *BlockStore) Content() string {
	curr := s.Start
	content := ""
	for curr != nil {
		if !curr.IsDeleted {
			content += curr.Content
		}
		curr = curr.Right
	}
	return content
}

// markerPos estimates position of a block (linear scan).
// TODO: what?
func (s *BlockStore) markerPos(block *block.Block) int {
	curr := s.Start
	pos := 0
	for curr != nil && curr != block {
		if !curr.IsDeleted {
			pos += len(curr.Content)
		}
		curr = curr.Right
	}
	return pos
}

================
File: internal/clock/clock.go
================
package clock

================
File: internal/marker/marker_test.go
================
package marker

================
File: internal/marker/marker.go
================
package marker

import (
	"errors"
	"time"

	"ygo/internal/block"
	"ygo/internal/utils"
)

var (
	ErrNoMarkers     = errors.New("no markers available")
	ErrInvalidPos    = errors.New("invalid position")
	ErrBlockNotFound = errors.New("block not found")
)

type OpType = int8

const (
	_ OpType = iota
	OpAdd
	OpDel
)

type Marker struct {
	Block     *block.Block
	Pos       int
	Timestamp int64
}

type MarkerSystem struct {
	Markers []Marker
}

// NewSystem creates a new marker system.
func NewSystem() *MarkerSystem {
	return &MarkerSystem{
		Markers: []Marker{},
	}
}

// Add creates a new marker for a given block at position.
func (ms *MarkerSystem) Add(block *block.Block, pos int) {
	ms.Markers = append(ms.Markers, Marker{
		Block:     block,
		Pos:       pos,
		Timestamp: time.Now().UnixMilli(),
	})
}

// FindBlock returns the closest marker-based block at given pos.
func (ms *MarkerSystem) FindBlock(start *block.Block, pos int) (Marker, error) {
	if len(ms.Markers) == 0 {
		return Marker{}, ErrNoMarkers
	}

	for _, m := range ms.Markers {
		if m.Pos == pos {
			return m, nil
		}
	}

	b := ms.Markers[0].Block
	p := ms.Markers[0].Pos

	// iterate right
	for {
		if b != nil && p < pos {
			break
		}
		if b.IsDeleted {
			if b.Right == nil {
				break
			}
			b = b.Right
		}
		if b.Right == nil {
			break
		}
		b = b.Right
		p += len(b.Content)
	}

	// iterate left
	for {
		if b != nil && p > pos {
			break
		}
		if b.IsDeleted {
			if b.Left == nil {
				break
			}
			b = b.Left
		}
		if b.Left == nil {
			break
		}
		b = b.Left
		p += len(b.Content)
	}

	final := Marker{
		Block:     b,
		Pos:       p,
		Timestamp: time.Now().UnixMilli(),
	}
	ms.Markers = append(ms.Markers, final)
	return final, nil
}

// UpdateMarkers adjusts marker positions after add/delete ops
func (ms *MarkerSystem) UpdateMarkers(pos int, delta int, op OpType) {
	for i := range ms.Markers {
		if ms.Markers[i].Pos >= pos {
			switch op {
			case OpAdd:
				ms.Markers[i].Pos += delta
			case OpDel:
				ms.Markers[i].Pos -= delta
			}
			ms.Markers[i].Timestamp = time.Now().UnixMilli()
		}
	}
}

// DeleteMarkerAt removes a marker by its position.
func (ms *MarkerSystem) DeleteMarkerAt(pos int) {
	newMarkers := make([]Marker, 0, len(ms.Markers))
	for _, m := range ms.Markers {
		if m.Pos != pos {
			newMarkers = append(newMarkers, m)
		}
	}
	ms.Markers = newMarkers
}

func (ms *MarkerSystem) DestroyMarkers() {
	ms.Markers = []Marker{}
}

func (ms *MarkerSystem) GetBlockPositionByClock(clock block.ID) (int, error) {
	for _, m := range ms.Markers {
		if utils.EqualID(m.Block.ID, clock) {
			return m.Pos, nil
		}
	}
	return -1, ErrInvalidPos
}

func (ms *MarkerSystem) GetBlockPositionByID(id *block.ID) (int, error) {
	if ms.Markers == nil || len(ms.Markers) == 0 {
		return -1, ErrNoMarkers
	}

	if id == nil {
		return -1, ErrInvalidPos
	}

	for _, m := range ms.Markers {
		if utils.EqualIDPtr(&m.Block.ID, id) {
			return m.Pos, nil
		}
	}

	return -1, ErrBlockNotFound
}

func (ms *MarkerSystem) DeleteMarkerAtPosition(pos int) {
	newMarkers := make([]Marker, 0, len(ms.Markers))
	for _, m := range ms.Markers {
		if m.Pos != pos {
			newMarkers = append(newMarkers, m)
		}
	}
	ms.Markers = newMarkers
}

================
File: internal/replay/types.go
================
package replay

================
File: internal/sync/update.go
================
package sync

================
File: internal/utils/utils.go
================
package utils

import "ygo/internal/block"

func EqualID(a, b block.ID) bool {
	return a.Client == b.Client && a.Clock == b.Clock
}

func EqualIDPtr(a, b *block.ID) bool {
	if a == nil || b == nil {
		return false
	}
	return EqualID(*a, *b)
}

================
File: test/blockstore_test.go
================
package test

================
File: main.go
================
package ygo
